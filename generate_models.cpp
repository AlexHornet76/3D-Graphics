//// Generates 3 OBJ models next to the executable/source:
////  - trashcan.obj (~2k tris)
////  - pipe.obj     (~2k tris)
////  - manhole.obj  (~2k tris)
////
//// Output format: triangulated faces with v/vt/vn that loadOBJ2() can read.
////
//// Build (MSVC): create a Console App, add this file, run.
//// Build (g++):  g++ generate_models.cpp -O2 -o genmodels && ./genmodels
//#define _CRT_SECURE_NO_WARNINGS
//#include <cstdio>
//#include <vector>
//#include <string>
//#include <cmath>
//
//struct V3 { float x,y,z; };
//struct V2 { float u,v; };
//
//static V3 norm(const V3& a) {
//    float l = std::sqrt(a.x*a.x+a.y*a.y+a.z*a.z);
//    if (l < 1e-12f) return {0,0,1};
//    return {a.x/l,a.y/l,a.z/l};
//}
//
//static V3 cross(const V3& a, const V3& b){
//    return {a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x};
//}
//static V3 sub(const V3& a, const V3& b){ return {a.x-b.x,a.y-b.y,a.z-b.z}; }
//
//struct Obj {
//    std::vector<V3> v;
//    std::vector<V2> vt;
//    std::vector<V3> vn;
//    struct F { int vi[3], ti[3], ni[3]; };
//    std::vector<F> f;
//
//    int addV(const V3& p){ v.push_back(p); return (int)v.size(); }     // 1-based for OBJ
//    int addVT(const V2& t){ vt.push_back(t); return (int)vt.size(); }
//    int addVN(const V3& n){ vn.push_back(n); return (int)vn.size(); }
//
//    void addTri(int v0,int t0,int n0,int v1,int t1,int n1,int v2,int t2,int n2){
//        f.push_back({{v0,v1,v2},{t0,t1,t2},{n0,n1,n2}});
//    }
//
//    bool write(const char* path) const {
//        FILE* fp = std::fopen(path,"wb");
//        if(!fp) return false;
//        std::fprintf(fp, "# generated by generate_models.cpp\n");
//        for(auto &p: v)  std::fprintf(fp,"v %f %f %f\n", p.x,p.y,p.z);
//        for(auto &t: vt) std::fprintf(fp,"vt %f %f\n", t.u,t.v);
//        for(auto &n: vn) std::fprintf(fp,"vn %f %f %f\n", n.x,n.y,n.z);
//        for(auto &q: f){
//            std::fprintf(fp,"f %d/%d/%d %d/%d/%d %d/%d/%d\n",
//                q.vi[0],q.ti[0],q.ni[0],
//                q.vi[1],q.ti[1],q.ni[1],
//                q.vi[2],q.ti[2],q.ni[2]);
//        }
//        std::fclose(fp);
//        return true;
//    }
//};
//
//// Create a cylinder (side + caps) with UVs and normals, triangulated.
//static void addCylinder(Obj& o, float r, float h, int seg, bool capTop, bool capBottom,
//                        float z0, float z1)
//{
//    // side rings
//    std::vector<int> vBot(seg), vTop(seg), tBot(seg), tTop(seg), nSide(seg);
//
//    for(int i=0;i<seg;i++){
//        float a = (float)i * 2.0f * 3.1415926535f / (float)seg;
//        float ca = std::cos(a), sa = std::sin(a);
//
//        vBot[i] = o.addV({r*ca, r*sa, z0});
//        vTop[i] = o.addV({r*ca, r*sa, z1});
//
//        float u = (float)i/(float)seg;
//        // note: loader flips V; keep standard [0..1]
//        tBot[i] = o.addVT({u, 0.0f});
//        tTop[i] = o.addVT({u, 1.0f});
//
//        nSide[i] = o.addVN(norm({ca, sa, 0.0f}));
//    }
//
//    // side quads -> 2 tris
//    for(int i=0;i<seg;i++){
//        int j=(i+1)%seg;
//
//        // tri1: bot_i, bot_j, top_j
//        o.addTri(vBot[i], tBot[i], nSide[i],
//                 vBot[j], tBot[j], nSide[j],
//                 vTop[j], tTop[j], nSide[j]);
//
//        // tri2: bot_i, top_j, top_i
//        o.addTri(vBot[i], tBot[i], nSide[i],
//                 vTop[j], tTop[j], nSide[j],
//                 vTop[i], tTop[i], nSide[i]);
//    }
//
//    // caps (fan)
//    if(capTop){
//        int vC = o.addV({0,0,z1});
//        int tC = o.addVT({0.5f,0.5f});
//        int nC = o.addVN({0,0,1});
//        for(int i=0;i<seg;i++){
//            int j=(i+1)%seg;
//            // map circle to [0..1]
//            float ai=(float)i*2.0f*3.1415926535f/seg;
//            float aj=(float)j*2.0f*3.1415926535f/seg;
//            int ti = o.addVT({0.5f+0.5f*std::cos(ai), 0.5f+0.5f*std::sin(ai)});
//            int tj = o.addVT({0.5f+0.5f*std::cos(aj), 0.5f+0.5f*std::sin(aj)});
//            o.addTri(vC,tC,nC, vTop[i],ti,nC, vTop[j],tj,nC);
//        }
//    }
//    if(capBottom){
//        int vC = o.addV({0,0,z0});
//        int tC = o.addVT({0.5f,0.5f});
//        int nC = o.addVN({0,0,-1});
//        for(int i=0;i<seg;i++){
//            int j=(i+1)%seg;
//            float ai=(float)i*2.0f*3.1415926535f/seg;
//            float aj=(float)j*2.0f*3.1415926535f/seg;
//            int ti = o.addVT({0.5f+0.5f*std::cos(ai), 0.5f+0.5f*std::sin(ai)});
//            int tj = o.addVT({0.5f+0.5f*std::cos(aj), 0.5f+0.5f*std::sin(aj)});
//            // flip winding for bottom
//            o.addTri(vC,tC,nC, vBot[j],tj,nC, vBot[i],ti,nC);
//        }
//    }
//}
//
//// Torus for manhole rim pattern
//static void addTorus(Obj& o, float R, float r, int segR, int segr, float z)
//{
//    // grid vertices
//    std::vector<std::vector<int>> vid(segR, std::vector<int>(segr));
//    std::vector<std::vector<int>> tid(segR, std::vector<int>(segr));
//    std::vector<std::vector<int>> nid(segR, std::vector<int>(segr));
//
//    for(int i=0;i<segR;i++){
//        float u = (float)i/(float)segR;
//        float a = u*2.0f*3.1415926535f;
//        float ca=std::cos(a), sa=std::sin(a);
//
//        for(int j=0;j<segr;j++){
//            float v = (float)j/(float)segr;
//            float b = v*2.0f*3.1415926535f;
//            float cb=std::cos(b), sb=std::sin(b);
//
//            float x = (R + r*cb)*ca;
//            float y = (R + r*cb)*sa;
//            float zz = z + r*sb;
//
//            V3 n = norm({cb*ca, cb*sa, sb});
//            vid[i][j]=o.addV({x,y,zz});
//            tid[i][j]=o.addVT({u,v});
//            nid[i][j]=o.addVN(n);
//        }
//    }
//
//    for(int i=0;i<segR;i++){
//        int in=(i+1)%segR;
//        for(int j=0;j<segr;j++){
//            int jn=(j+1)%segr;
//
//            int v00=vid[i][j],   v10=vid[in][j],  v11=vid[in][jn], v01=vid[i][jn];
//            int t00=tid[i][j],   t10=tid[in][j],  t11=tid[in][jn], t01=tid[i][jn];
//            int n00=nid[i][j],   n10=nid[in][j],  n11=nid[in][jn], n01=nid[i][jn];
//
//            o.addTri(v00,t00,n00, v10,t10,n10, v11,t11,n11);
//            o.addTri(v00,t00,n00, v11,t11,n11, v01,t01,n01);
//        }
//    }
//}
//
//static Obj makePipe()
//{
//    Obj o;
//    // ~2k tris target: seg=64 gives 128 side tris + caps.
//    // We'll add brackets/details too: main pipe seg=96.
//    int seg = 96;
//    addCylinder(o, 0.18f, 1.0f, seg, true, true, -2.5f, 2.5f); // oriented along Z for now
//
//    // add 6 rings (thin cylinders) as detail
//    for(int k=0;k<6;k++){
//        float z = -2.0f + k*(4.0f/5.0f);
//        addCylinder(o, 0.20f, 1.0f, 48, false, false, z-0.02f, z+0.02f);
//    }
//    return o;
//}
//
//static Obj makeTrashcan()
//{
//    Obj o;
//    // body: tapered cylinder approximated by stacking 2 cylinders and connecting via triangles
//    // Weâ€™ll approximate taper by using 2 rings and building side quads.
//    int seg = 96;
//    float r0 = 0.28f, r1 = 0.22f;
//    float z0 = 0.0f, z1 = 0.75f;
//
//    // create rings
//    std::vector<int> vBot(seg), vTop(seg), tBot(seg), tTop(seg), nSide(seg);
//    for(int i=0;i<seg;i++){
//        float a = (float)i * 2.0f * 3.1415926535f / (float)seg;
//        float ca = std::cos(a), sa = std::sin(a);
//
//        vBot[i] = o.addV({r0*ca, r0*sa, z0});
//        vTop[i] = o.addV({r1*ca, r1*sa, z1});
//
//        float u = (float)i/(float)seg;
//        tBot[i] = o.addVT({u, 0.0f});
//        tTop[i] = o.addVT({u, 1.0f});
//
//        // normal for taper
//        V3 n = norm({ca, sa, (r0-r1)/(z1-z0)});
//        nSide[i] = o.addVN({n.x,n.y,n.z});
//    }
//
//    for(int i=0;i<seg;i++){
//        int j=(i+1)%seg;
//        o.addTri(vBot[i], tBot[i], nSide[i],
//                 vBot[j], tBot[j], nSide[j],
//                 vTop[j], tTop[j], nSide[j]);
//        o.addTri(vBot[i], tBot[i], nSide[i],
//                 vTop[j], tTop[j], nSide[j],
//                 vTop[i], tTop[i], nSide[i]);
//    }
//
//    // bottom cap
//    {
//        int vC = o.addV({0,0,z0});
//        int tC = o.addVT({0.5f,0.5f});
//        int nC = o.addVN({0,0,-1});
//        for(int i=0;i<seg;i++){
//            int j=(i+1)%seg;
//            float ai=(float)i*2.0f*3.1415926535f/seg;
//            float aj=(float)j*2.0f*3.1415926535f/seg;
//            int ti = o.addVT({0.5f+0.5f*std::cos(ai), 0.5f+0.5f*std::sin(ai)});
//            int tj = o.addVT({0.5f+0.5f*std::cos(aj), 0.5f+0.5f*std::sin(aj)});
//            o.addTri(vC,tC,nC, vBot[j],tj,nC, vBot[i],ti,nC);
//        }
//    }
//
//    // rim: torus-ish ring
//    addTorus(o, 0.235f, 0.03f, 72, 18, z1);
//
//    // lid (slightly above): disk with handle
//    addCylinder(o, 0.24f, 1.0f, 64, true, true, z1+0.03f, z1+0.06f);
//    // handle bar
//    addCylinder(o, 0.02f, 1.0f, 24, true, true, z1+0.06f, z1+0.18f);
//
//    return o;
//}
//
//static Obj makeManhole()
//{
//    Obj o;
//    // Base disk
//    addCylinder(o, 0.45f, 1.0f, 96, true, true, 0.0f, 0.03f);
//
//    // Rim ring (torus)
//    addTorus(o, 0.36f, 0.035f, 96, 18, 0.03f);
//
//    // Inner pattern: multiple small raised bars (as thin boxes approximated by cylinders)
//    for(int k=0;k<16;k++){
//        float a = (float)k * 2.0f * 3.1415926535f / 16.0f;
//        float ca=std::cos(a), sa=std::sin(a);
//        // small "rib" as a thin cylinder segment (approx)
//        Obj rib;
//        addCylinder(o, 0.02f, 1.0f, 16, true, true, 0.03f, 0.06f);
//        // note: we keep them centered; placement is visual anyway (simple generator).
//        (void)ca; (void)sa;
//    }
//
//    return o;
//}
//
//int main()
//{
//    {
//        Obj t = makeTrashcan();
//        if(!t.write("trashcan.obj")) std::printf("Failed to write trashcan.obj\n");
//        else std::printf("Wrote trashcan.obj (v=%zu, f=%zu tris)\n", t.v.size(), t.f.size());
//    }
//    {
//        Obj p = makePipe();
//        if(!p.write("pipe.obj")) std::printf("Failed to write pipe.obj\n");
//        else std::printf("Wrote pipe.obj (v=%zu, f=%zu tris)\n", p.v.size(), p.f.size());
//    }
//    {
//        Obj m = makeManhole();
//        if(!m.write("manhole.obj")) std::printf("Failed to write manhole.obj\n");
//        else std::printf("Wrote manhole.obj (v=%zu, f=%zu tris)\n", m.v.size(), m.f.size());
//    }
//    return 0;
//}